<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stereo Feature Matcher & Anaglyph Tool</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .canvas-container::-webkit-scrollbar {
            height: 8px; width: 8px;
        }
        .canvas-container::-webkit-scrollbar-track {
            background: #1f2937;
        }
        .canvas-container::-webkit-scrollbar-thumb {
            background: #4b5563; border-radius: 4px;
        }
        .loader {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            width: 16px; height: 16px;
            animation: spin 1s linear infinite;
            display: inline-block;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Image preview thumbnails */
        .thumbnail-preview {
            max-height: 60px;
            border-radius: 4px;
            border: 1px solid #4b5563;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen flex flex-col font-sans text-sm">

    <!-- Header -->
    <header class="bg-gray-800 border-b border-gray-700 p-3 shadow-lg">
        <div class="container mx-auto flex justify-between items-center">
            <h1 class="text-lg font-bold text-blue-400 flex items-center gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
                </svg>
                Stereo Feature Matcher Pro
            </h1>
            <div class="flex items-center gap-4">
                <span id="backendStatus" class="text-xs text-yellow-400 font-mono">Connecting to backend...</span>
                <span id="status" class="text-xs text-green-400 font-bold font-mono hidden">Ready</span>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="flex-grow container mx-auto p-3 flex flex-col gap-4">
        
        <!-- Controls Grid -->
        <div class="bg-gray-800 rounded-lg p-4 shadow-lg border border-gray-700 grid grid-cols-1 lg:grid-cols-12 gap-4">
            
            <!-- Column 1: Inputs & Detectors (3 cols) -->
            <div class="lg:col-span-3 space-y-3 border-b lg:border-b-0 lg:border-r border-gray-700 pb-3 lg:pb-0 lg:pr-3">
                <h3 class="font-semibold text-gray-300 mb-2">1. Input & Method</h3>
                <div class="space-y-1">
                    <label class="block text-xs text-gray-500">Left Image</label>
                    <input type="file" id="fileInput1" accept="image/*" class="block w-full text-xs text-gray-400 file:mr-2 file:py-1 file:px-2 file:rounded file:border-0 file:text-xs file:bg-blue-900 file:text-blue-200 hover:file:bg-blue-800 cursor-pointer bg-gray-900 rounded border border-gray-600">
                    <img id="preview1" class="thumbnail-preview hidden mt-1">
                </div>
                <div class="space-y-1">
                    <label class="block text-xs text-gray-500">Right Image</label>
                    <input type="file" id="fileInput2" accept="image/*" class="block w-full text-xs text-gray-400 file:mr-2 file:py-1 file:px-2 file:rounded file:border-0 file:text-xs file:bg-blue-900 file:text-blue-200 hover:file:bg-blue-800 cursor-pointer bg-gray-900 rounded border border-gray-600">
                    <img id="preview2" class="thumbnail-preview hidden mt-1">
                </div>

                <!-- Matching Mode Toggle -->
                <div class="space-y-1">
                    <label class="block text-xs text-gray-500">Matching Mode</label>
                    <div class="flex gap-1">
                        <button id="modeTraditional" class="flex-1 py-1 px-2 text-xs rounded-l border border-gray-600 bg-blue-600 text-white transition-colors" onclick="setMatchingMode('traditional')">Traditional</button>
                        <button id="modeDense" class="flex-1 py-1 px-2 text-xs rounded-r border border-gray-600 bg-gray-700 text-gray-300 hover:bg-gray-600 transition-colors" onclick="setMatchingMode('dense')">Deep Learning</button>
                    </div>
                </div>

                <!-- Traditional Detector Selection -->
                <div id="traditionalOptions" class="space-y-1">
                    <label class="block text-xs text-gray-500">Detector</label>
                    <select id="detectorSelect" class="w-full bg-gray-900 border border-gray-600 text-white text-xs rounded p-1.5 focus:ring-blue-500">
                        <option value="ORB">ORB (Default)</option>
                        <option value="AKAZE">AKAZE (Robust)</option>
                        <option value="BRISK">BRISK</option>
                        <option value="SIFT">SIFT</option>
                        <option value="SURF">SURF</option>
                    </select>
                </div>

                <!-- Dense Matcher Selection (hidden by default) -->
                <div id="denseOptions" class="space-y-2 hidden">
                    <div class="space-y-1">
                        <label class="block text-xs text-gray-500">Dense Matcher</label>
                        <select id="denseMatcherSelect" class="w-full bg-gray-900 border border-gray-600 text-white text-xs rounded p-1.5 focus:ring-blue-500">
                            <option value="SuperPoint+LightGlue">SuperPoint + LightGlue</option>
                            <option value="DISK+LightGlue">DISK + LightGlue</option>
                            <option value="EfficientLoFTR">EfficientLoFTR</option>
                        </select>
                    </div>
                    <div>
                        <div class="flex justify-between">
                            <span class="text-xs text-gray-400">Confidence Threshold</span>
                            <span id="denseThreshVal" class="text-xs text-blue-400">0.0</span>
                        </div>
                        <input type="range" id="denseThreshold" min="0" max="0.95" step="0.05" value="0" class="w-full h-1 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                    </div>
                    <p class="text-xs text-yellow-500/70" id="denseWarning">Requires: pip install torch transformers</p>
                </div>
            </div>

            <!-- Column 2: Advanced Filtering (5 cols) -->
            <div class="lg:col-span-5 space-y-3 border-b lg:border-b-0 lg:border-r border-gray-700 pb-3 lg:pb-0 lg:px-3">
                <h3 class="font-semibold text-gray-300 mb-2">2. Match Filtering</h3>
                
                <!-- Rank Range -->
                <div class="flex gap-2 items-center">
                    <div class="w-1/2">
                        <label class="block text-xs text-gray-500 mb-1">Rank Start</label>
                        <input type="number" id="rankStart" value="0" min="0" class="w-full bg-gray-900 border border-gray-600 rounded p-1 text-xs">
                    </div>
                    <div class="w-1/2">
                        <label class="block text-xs text-gray-500 mb-1">Rank End</label>
                        <input type="number" id="rankEnd" value="9999" min="1" class="w-full bg-gray-900 border border-gray-600 rounded p-1 text-xs">
                    </div>
                </div>

                <!-- Lowe's Ratio -->
                <div>
                    <div class="flex justify-between">
                        <label class="flex items-center gap-2 cursor-pointer">
                            <input type="checkbox" id="useLowe" class="rounded bg-gray-700 border-gray-600 text-blue-600 focus:ring-blue-500">
                            <span class="text-xs text-gray-400">Lowe's Ratio Test</span>
                        </label>
                        <span id="loweVal" class="text-xs text-blue-400">0.75</span>
                    </div>
                    <input type="range" id="loweRatio" min="0.1" max="0.95" step="0.05" value="0.75" class="w-full h-1 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                </div>

                <!-- Max Spatial Distance -->
                <div>
                    <div class="flex justify-between">
                        <span class="text-xs text-gray-400">Max Match Length (px)</span>
                        <span id="distVal" class="text-xs text-blue-400">No Limit</span>
                    </div>
                    <input type="range" id="maxDist" min="0" max="2000" step="50" value="2000" class="w-full h-1 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                </div>
            </div>

            <!-- Column 3: Actions & Viz (4 cols) -->
            <div class="lg:col-span-4 flex flex-col justify-between space-y-3 pl-0 lg:pl-3">
                <div>
                    <h3 class="font-semibold text-gray-300 mb-2">3. Visualization</h3>
                    <select id="vizMode" class="w-full bg-gray-900 border border-gray-600 text-white text-xs rounded p-1.5 mb-3">
                        <option value="sidebyside">Side-by-Side (Montage)</option>
                        <option value="anaglyph">Anaglyph (Red/Cyan Overlay)</option>
                    </select>
                </div>

                <div class="space-y-2">
                    <button id="runBtn" class="w-full py-2 bg-green-600 hover:bg-green-700 text-white font-bold rounded shadow transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center gap-2" disabled>
                        <span>▶</span> Compute Matches
                    </button>
                    
                    <!-- Robust Estimation Settings -->
                    <div class="bg-gray-900 rounded p-2 space-y-2">
                        <div class="flex gap-2">
                            <select id="robustMethod" class="flex-1 bg-gray-800 border border-gray-600 text-gray-300 text-xs rounded p-1.5" disabled>
                                <option value="RANSAC">RANSAC</option>
                                <option value="LMEDS">LMEDS</option>
                                <option value="MAGSAC++">MAGSAC++</option>
                                <option value="RHO">RHO</option>
                            </select>
                            <select id="modelType" class="flex-1 bg-gray-800 border border-gray-600 text-gray-300 text-xs rounded p-1.5" disabled title="Fundamental matrix is better for stereo pairs">
                                <option value="homography">Homography</option>
                                <option value="fundamental" selected>Fundamental (Stereo)</option>
                            </select>
                        </div>
                        
                        <div>
                            <div class="flex justify-between items-center">
                                <span class="text-xs text-gray-400">Reproj. Threshold</span>
                                <span id="reprojThresholdValue" class="text-xs text-gray-300 font-mono">5.0 px</span>
                            </div>
                            <input type="range" id="reprojThreshold" min="0.5" max="50" step="0.5" value="5.0" class="w-full h-1 bg-gray-700 rounded-lg appearance-none cursor-pointer" disabled>
                        </div>
                        
                        <div>
                            <div class="flex justify-between items-center">
                                <span class="text-xs text-gray-400">Confidence</span>
                                <span id="confidenceValue" class="text-xs text-gray-300 font-mono">0.995</span>
                            </div>
                            <input type="range" id="confidence" min="0.9" max="0.9999" step="0.001" value="0.995" class="w-full h-1 bg-gray-700 rounded-lg appearance-none cursor-pointer" disabled>
                        </div>
                        
                        <div>
                            <div class="flex justify-between items-center">
                                <span class="text-xs text-gray-400">Max Iterations</span>
                                <span id="maxItersValue" class="text-xs text-gray-300 font-mono">2000</span>
                            </div>
                            <input type="range" id="maxIters" min="100" max="10000" step="100" value="2000" class="w-full h-1 bg-gray-700 rounded-lg appearance-none cursor-pointer" disabled>
                        </div>
                        
                        <button id="refineBtn" class="w-full py-1.5 bg-purple-600 hover:bg-purple-700 text-white text-xs font-semibold rounded shadow transition-colors disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                            Refine Matches
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Output Area -->
        <div class="flex-grow bg-gray-800 rounded-lg shadow-lg border border-gray-700 flex flex-col overflow-hidden relative min-h-[400px]">
            <div class="absolute top-0 left-0 bg-gray-900/90 text-xs px-3 py-1.5 rounded-br-lg z-10 border-b border-r border-gray-700 shadow flex items-center gap-4" id="statusBar">
                <span id="outputInfo" class="text-gray-300">Ready</span>
                <span id="timingInfo" class="text-blue-400 hidden"></span>
                <span id="gpuInfo" class="text-purple-400 hidden"></span>
            </div>
            <div class="canvas-container w-full h-full overflow-auto flex items-center justify-center p-4 bg-gray-900 bg-[radial-gradient(#374151_1px,transparent_1px)] [background-size:16px_16px]">
                <img id="outputImage" class="max-w-full max-h-full shadow-2xl hidden">
                <div id="placeholder" class="text-gray-500 text-center">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-16 w-16 mx-auto mb-2 opacity-50" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
                    </svg>
                    <p>Load images and click "Compute Matches"</p>
                </div>
            </div>
        </div>

    </main>

    <script type="text/javascript">
        // API Configuration
        const API_BASE = window.location.origin;
        
        // Application State
        let appState = {
            image1Base64: null,
            image2Base64: null,
            keypoints1: null,
            keypoints2: null,
            currentMatches: null,
            availableDetectors: [],
            availableMethods: [],
            availableDenseMatchers: [],
            matchingMode: 'traditional'  // 'traditional' or 'dense'
        };

        // --- UI Elements ---
        const runBtn = document.getElementById('runBtn');
        const refineBtn = document.getElementById('refineBtn');
        const robustSelect = document.getElementById('robustMethod');
        const outputInfo = document.getElementById('outputInfo');
        const outputImage = document.getElementById('outputImage');
        const placeholder = document.getElementById('placeholder');
        const backendStatus = document.getElementById('backendStatus');
        const statusEl = document.getElementById('status');
        const detectorSelect = document.getElementById('detectorSelect');
        const denseMatcherSelect = document.getElementById('denseMatcherSelect');

        // --- Mode Switching ---
        function setMatchingMode(mode) {
            appState.matchingMode = mode;
            const traditionalBtn = document.getElementById('modeTraditional');
            const denseBtn = document.getElementById('modeDense');
            const traditionalOpts = document.getElementById('traditionalOptions');
            const denseOpts = document.getElementById('denseOptions');

            if (mode === 'traditional') {
                traditionalBtn.className = 'flex-1 py-1 px-2 text-xs rounded-l border border-gray-600 bg-blue-600 text-white transition-colors';
                denseBtn.className = 'flex-1 py-1 px-2 text-xs rounded-r border border-gray-600 bg-gray-700 text-gray-300 hover:bg-gray-600 transition-colors';
                traditionalOpts.classList.remove('hidden');
                denseOpts.classList.add('hidden');
                runBtn.innerHTML = '<span>▶</span> Compute Matches';
            } else {
                traditionalBtn.className = 'flex-1 py-1 px-2 text-xs rounded-l border border-gray-600 bg-gray-700 text-gray-300 hover:bg-gray-600 transition-colors';
                denseBtn.className = 'flex-1 py-1 px-2 text-xs rounded-r border border-gray-600 bg-purple-600 text-white transition-colors';
                traditionalOpts.classList.add('hidden');
                denseOpts.classList.remove('hidden');
                runBtn.innerHTML = '<span>▶</span> Dense Match';
            }
        }
        // Make it globally accessible
        window.setMatchingMode = setMatchingMode;

        // --- Initialize ---
        async function init() {
            try {
                // Check backend health
                const health = await fetch(`${API_BASE}/api/health`);
                if (!health.ok) throw new Error('Backend not responding');
                
                // Get available detectors
                const detectorsResp = await fetch(`${API_BASE}/api/detectors`);
                const detectorsData = await detectorsResp.json();
                appState.availableDetectors = detectorsData.detectors;
                
                // Update detector dropdown
                detectorSelect.innerHTML = '';
                for (const det of appState.availableDetectors) {
                    const opt = document.createElement('option');
                    opt.value = det.name;
                    opt.textContent = det.name + (det.available ? '' : ' (N/A)');
                    opt.disabled = !det.available;
                    detectorSelect.appendChild(opt);
                }
                
                // Get available robust methods
                const methodsResp = await fetch(`${API_BASE}/api/robust-methods`);
                const methodsData = await methodsResp.json();
                appState.availableMethods = methodsData.methods;

                // Update robust method dropdown
                robustSelect.innerHTML = '';
                for (const method of appState.availableMethods) {
                    const opt = document.createElement('option');
                    opt.value = method.name;
                    opt.textContent = method.name + (method.available ? '' : ' (N/A)');
                    opt.disabled = !method.available;
                    robustSelect.appendChild(opt);
                }

                // Get available dense matchers
                const denseResp = await fetch(`${API_BASE}/api/dense-matchers`);
                const denseData = await denseResp.json();
                appState.availableDenseMatchers = denseData.matchers;

                // Update dense matcher dropdown
                denseMatcherSelect.innerHTML = '';
                let anyDenseAvailable = false;
                for (const matcher of appState.availableDenseMatchers) {
                    const opt = document.createElement('option');
                    opt.value = matcher.name;
                    opt.textContent = matcher.name + (matcher.available ? '' : ' (N/A)');
                    opt.disabled = !matcher.available;
                    if (matcher.available) anyDenseAvailable = true;
                    denseMatcherSelect.appendChild(opt);
                }

                // Update warning visibility
                const denseWarning = document.getElementById('denseWarning');
                if (anyDenseAvailable) {
                    denseWarning.classList.add('hidden');
                }

                // Update UI
                backendStatus.textContent = 'Backend Connected';
                backendStatus.className = 'text-xs text-green-400 font-mono';
                statusEl.classList.remove('hidden');
                runBtn.disabled = false;
                
            } catch (err) {
                console.error('Failed to connect to backend:', err);
                backendStatus.textContent = 'Backend Offline - Start with: uvicorn backend.main:app --reload';
                backendStatus.className = 'text-xs text-red-400 font-mono';
            }
        }

        // --- UI Event Listeners ---
        document.getElementById('loweRatio').addEventListener('input', (e) => {
            document.getElementById('loweVal').innerText = e.target.value;
        });

        document.getElementById('maxDist').addEventListener('input', (e) => {
            const val = e.target.value;
            document.getElementById('distVal').innerText = val >= 2000 ? "No Limit" : val + "px";
        });

        document.getElementById('denseThreshold').addEventListener('input', (e) => {
            document.getElementById('denseThreshVal').innerText = e.target.value;
        });

        // Robust estimation parameter sliders
        document.getElementById('reprojThreshold').addEventListener('input', (e) => {
            document.getElementById('reprojThresholdValue').innerText = e.target.value + ' px';
        });

        document.getElementById('confidence').addEventListener('input', (e) => {
            document.getElementById('confidenceValue').innerText = parseFloat(e.target.value).toFixed(4);
        });

        document.getElementById('maxIters').addEventListener('input', (e) => {
            document.getElementById('maxItersValue').innerText = e.target.value;
        });

        // File input handlers with preview
        document.getElementById('fileInput1').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                appState.image1Base64 = await fileToBase64(file);
                document.getElementById('preview1').src = appState.image1Base64;
                document.getElementById('preview1').classList.remove('hidden');
            }
        });
        
        document.getElementById('fileInput2').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                appState.image2Base64 = await fileToBase64(file);
                document.getElementById('preview2').src = appState.image2Base64;
                document.getElementById('preview2').classList.remove('hidden');
            }
        });

        // --- Utility Functions ---
        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        function showResult(imageData) {
            outputImage.src = imageData;
            outputImage.classList.remove('hidden');
            placeholder.classList.add('hidden');
        }

        function showTiming(timing, gpuMemory) {
            const timingEl = document.getElementById('timingInfo');
            const gpuEl = document.getElementById('gpuInfo');

            if (timing) {
                let parts = [];
                if (timing.detection_ms) parts.push(`Det: ${timing.detection_ms}ms`);
                if (timing.matching_ms) parts.push(`Match: ${timing.matching_ms}ms`);
                if (timing.refinement_ms) parts.push(`Refine: ${timing.refinement_ms}ms`);
                if (timing.visualization_ms) parts.push(`Viz: ${timing.visualization_ms}ms`);
                parts.push(`Total: ${timing.total_ms}ms`);
                timingEl.textContent = parts.join(' | ');
                timingEl.classList.remove('hidden');
            } else {
                timingEl.classList.add('hidden');
            }

            if (gpuMemory) {
                gpuEl.textContent = `GPU: ${gpuMemory.allocated_mb}MB / ${gpuMemory.total_mb}MB`;
                gpuEl.classList.remove('hidden');
            } else {
                gpuEl.classList.add('hidden');
            }
        }

        // --- Main Compute Logic ---
        runBtn.addEventListener('click', async () => {
            if (!appState.image1Base64 || !appState.image2Base64) {
                alert("Please upload both images first.");
                return;
            }

            runBtn.disabled = true;
            const originalBtnText = appState.matchingMode === 'dense' ? '<span>▶</span> Dense Match' : '<span>▶</span> Compute Matches';
            runBtn.innerHTML = '<span class="loader"></span> Computing...';
            refineBtn.disabled = true;
            robustSelect.disabled = true;
            document.getElementById('modelType').disabled = true;
            document.getElementById('reprojThreshold').disabled = true;
            document.getElementById('confidence').disabled = true;
            document.getElementById('maxIters').disabled = true;
            outputInfo.textContent = 'Processing...';

            try {
                let response, data;

                if (appState.matchingMode === 'dense') {
                    // Dense matching mode
                    const requestBody = {
                        image1: appState.image1Base64,
                        image2: appState.image2Base64,
                        matcher: document.getElementById('denseMatcherSelect').value,
                        threshold: parseFloat(document.getElementById('denseThreshold').value),
                        rank_start: parseInt(document.getElementById('rankStart').value) || 0,
                        rank_end: parseInt(document.getElementById('rankEnd').value) || 500,
                        viz_mode: document.getElementById('vizMode').value
                    };

                    response = await fetch(`${API_BASE}/api/dense-match`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(requestBody)
                    });

                    data = await response.json();

                    if (data.success) {
                        showResult(data.result_image);
                        outputInfo.textContent = data.message;
                        showTiming(data.timing, data.gpu_memory);

                        // Dense matches don't support refinement in the same way
                        appState.keypoints1 = null;
                        appState.keypoints2 = null;
                        appState.currentMatches = null;
                        refineBtn.disabled = true;
                        robustSelect.disabled = true;
                    } else {
                        alert("Error: " + data.message);
                        outputInfo.textContent = "Error: " + data.message;
                        showTiming(null, null);
                    }

                } else {
                    // Traditional matching mode
                    const requestBody = {
                        image1: appState.image1Base64,
                        image2: appState.image2Base64,
                        detector: document.getElementById('detectorSelect').value,
                        use_ratio_test: document.getElementById('useLowe').checked,
                        ratio_threshold: parseFloat(document.getElementById('loweRatio').value),
                        rank_start: parseInt(document.getElementById('rankStart').value) || 0,
                        rank_end: parseInt(document.getElementById('rankEnd').value) || 9999,
                        max_spatial_distance: parseFloat(document.getElementById('maxDist').value) < 2000
                            ? parseFloat(document.getElementById('maxDist').value)
                            : null,
                        viz_mode: document.getElementById('vizMode').value
                    };

                    response = await fetch(`${API_BASE}/api/match`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(requestBody)
                    });

                    data = await response.json();

                    if (data.success) {
                        showResult(data.result_image);
                        outputInfo.textContent = data.message;
                        showTiming(data.timing, null);

                        // Store state for refinement
                        appState.keypoints1 = data.keypoints1;
                        appState.keypoints2 = data.keypoints2;
                        appState.currentMatches = data.matches;

                        // Enable refine controls if we have enough matches
                        if (data.num_matches >= 4) {
                            refineBtn.disabled = false;
                            robustSelect.disabled = false;
                            document.getElementById('modelType').disabled = false;
                            document.getElementById('reprojThreshold').disabled = false;
                            document.getElementById('confidence').disabled = false;
                            document.getElementById('maxIters').disabled = false;
                        }
                    } else {
                        alert("Error: " + data.message);
                        outputInfo.textContent = "Error: " + data.message;
                        showTiming(null, null);
                    }
                }

            } catch (err) {
                console.error('Compute error:', err);
                alert("Error: " + err.message);
                outputInfo.textContent = "Error occurred";
            } finally {
                runBtn.disabled = false;
                runBtn.innerHTML = originalBtnText;
            }
        });

        // --- Refine Logic ---
        refineBtn.addEventListener('click', async () => {
            const modelType = document.getElementById('modelType').value;
            const minMatches = modelType === 'fundamental' ? 8 : 4;
            
            if (!appState.currentMatches || appState.currentMatches.length < minMatches) {
                alert(`Need at least ${minMatches} matches to refine with ${modelType}.`);
                return;
            }

            refineBtn.disabled = true;
            refineBtn.textContent = 'Refining...';

            try {
                const requestBody = {
                    image1: appState.image1Base64,
                    image2: appState.image2Base64,
                    keypoints1: appState.keypoints1,
                    keypoints2: appState.keypoints2,
                    matches: appState.currentMatches,
                    method: document.getElementById('robustMethod').value,
                    model_type: modelType,
                    reproj_threshold: parseFloat(document.getElementById('reprojThreshold').value),
                    confidence: parseFloat(document.getElementById('confidence').value),
                    max_iters: parseInt(document.getElementById('maxIters').value),
                    viz_mode: document.getElementById('vizMode').value
                };

                const response = await fetch(`${API_BASE}/api/refine`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });

                const data = await response.json();

                if (data.success) {
                    showResult(data.result_image);
                    outputInfo.textContent += ` | ${data.message}`;
                    showTiming(data.timing, null);

                    // Update matches with inliers only
                    appState.currentMatches = data.matches;
                } else {
                    alert("Refinement failed: " + data.message);
                }

            } catch (err) {
                console.error('Refine error:', err);
                alert("Error: " + err.message);
            } finally {
                refineBtn.disabled = false;
                refineBtn.textContent = 'Refine';
            }
        });

        // --- Visualization Mode Change ---
        document.getElementById('vizMode').addEventListener('change', async () => {
            // If we have matches, re-render with new viz mode
            if (appState.currentMatches && appState.currentMatches.length > 0) {
                // Trigger a re-compute to update visualization
                // For efficiency, you could implement a separate render endpoint
                runBtn.click();
            }
        });

        // Initialize on load
        init();
    </script>
</body>
</html>
